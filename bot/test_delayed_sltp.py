#!/usr/bin/env python3
"""
Test du syst√®me SL/TP retard√© - VERSION CORRIG√âE
Ce fichier permet de tester la fonctionnalit√© sans avoir besoin de signaux r√©els
"""
import sys
import os
import time
from datetime import datetime, timedelta
import traceback

# Ajouter le r√©pertoire du bot au path
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

print("üß™ D√âBUT INITIALISATION TESTEUR SL/TP RETARD√â")
print("=" * 60)

# Test des imports un par un
try:
    print("üì¶ Import config...")
    import config
    print("‚úÖ Config import√©")
except Exception as e:
    print(f"‚ùå Erreur import config: {e}")
    sys.exit(1)

try:
    print("üì¶ Import trading_logger...")
    from trading_logger import trading_logger
    print("‚úÖ TradingLogger import√©")
except Exception as e:
    print(f"‚ùå Erreur import trading_logger: {e}")
    print("Continuons sans logger...")
    trading_logger = None

try:
    print("üì¶ Import delayed_sltp_manager...")
    from delayed_sltp_manager import DelayedSLTPManager
    print("‚úÖ DelayedSLTPManager import√©")
except Exception as e:
    print(f"‚ùå Erreur import delayed_sltp_manager: {e}")
    print("Traceback complet:")
    traceback.print_exc()
    sys.exit(1)

print("‚úÖ Tous les imports r√©ussis!")

# V√©rifier la configuration
try:
    print("üîß V√©rification configuration...")
    
    # S'assurer que DELAYED_SLTP_CONFIG existe
    if not hasattr(config, 'DELAYED_SLTP_CONFIG'):
        print("‚ö†Ô∏è DELAYED_SLTP_CONFIG manquant, cr√©ation par d√©faut...")
        config.DELAYED_SLTP_CONFIG = {
            'ENABLED': True,
            'PRICE_OFFSET_PERCENT': 0.01,
            'CHECK_INTERVAL_SECONDS': 10,
            'AUTO_CLEANUP_HOURS': 24,
            'LOG_DETAILED_CALCULATIONS': True,
        }
    
    # S'assurer que ASSET_CONFIG existe
    if not hasattr(config, 'ASSET_CONFIG'):
        print("‚ö†Ô∏è ASSET_CONFIG manquant, cr√©ation par d√©faut...")
        config.ASSET_CONFIG = {
            'SYMBOL': 'BTCUSDT',
            'TIMEFRAME': '5m',
            'BALANCE_ASSET': 'USDT'
        }
    
    print(f"‚úÖ Configuration v√©rifi√©e:")
    print(f"   Symbole: {config.ASSET_CONFIG['SYMBOL']}")
    print(f"   Timeframe: {config.ASSET_CONFIG['TIMEFRAME']}")
    print(f"   Offset: {config.DELAYED_SLTP_CONFIG['PRICE_OFFSET_PERCENT']}%")
    
except Exception as e:
    print(f"‚ùå Erreur configuration: {e}")
    traceback.print_exc()
    sys.exit(1)

# Classes Mock am√©lior√©es
class MockPositionManager:
    """Mock PositionManager pour les tests"""
    def format_price(self, price):
        try:
            return round(float(price), 2)
        except:
            return 43200.00  # Fallback

class MockTradeExecutor:
    """Mock TradeExecutor pour les tests"""
    def __init__(self):
        self.position_manager = MockPositionManager()
        self.active_trades = {}
        self.trade_counter = 0
        print("‚úÖ MockTradeExecutor initialis√©")
        
    def get_current_price(self):
        return 43200.50  # Prix de test fixe
    
    def place_stop_loss_order(self, side, quantity, price, trade_id):
        print(f"üìã MOCK: Place SL order {side} {quantity} @ {price} pour {trade_id}")
        return f"sl_order_{int(time.time())}"
    
    def place_take_profit_order(self, side, quantity, price, trade_id):
        print(f"üìã MOCK: Place TP order {side} {quantity} @ {price} pour {trade_id}")
        return f"tp_order_{int(time.time())}"

class DelayedSLTPTester:
    """Classe de test pour le syst√®me SL/TP retard√©"""
    
    def __init__(self):
        print("\nüß™ Initialisation du testeur SL/TP retard√©...")
        
        try:
            self.mock_executor = MockTradeExecutor()
            print("‚úÖ Mock executor cr√©√©")
            
            # Utiliser type: ignore pour √©viter l'erreur Pylance
            self.delayed_manager = DelayedSLTPManager(self.mock_executor, None)  # type: ignore
            print("‚úÖ DelayedSLTPManager cr√©√©")
            
            self.test_results = []
            
            print(f"‚úÖ Testeur initialis√© avec succ√®s!")
            print(f"Configuration: Offset = {config.DELAYED_SLTP_CONFIG.get('PRICE_OFFSET_PERCENT', 0.01)}%")
            
        except Exception as e:
            print(f"‚ùå Erreur initialisation testeur: {e}")
            traceback.print_exc()
            raise
        
    def create_test_trade(self, trade_id, side, entry_price, quantity, sl_price, tp_price):
        """Cr√©e un trade de test"""
        return {
            'trade_id': trade_id,
            'side': side,
            'entry_price': entry_price,
            'quantity': quantity,
            'sl_price': sl_price,
            'tp_price': tp_price
        }
    
    def test_scenario_1_prix_stable(self):
        """Test Sc√©nario 1: Prix reste entre SL et TP - Pas d'offset"""
        print("\n" + "="*60)
        print("üß™ TEST SC√âNARIO 1: Prix stable - Pas d'offset")
        print("="*60)
        
        try:
            # Configuration du test
            trade_id = "test_stable_001"
            entry_time = datetime.now()
            
            # Trade LONG √† 43200, SL √† 43150, TP √† 43265
            trade_data = self.create_test_trade(
                trade_id=trade_id,
                side="LONG", 
                entry_price=43202.50,
                quantity=0.023,
                sl_price=43150.00,
                tp_price=43265.00
            )
            
            print(f"üìä Trade test: {trade_data['side']} @ {trade_data['entry_price']}")
            print(f"   SL original: {trade_data['sl_price']}")
            print(f"   TP original: {trade_data['tp_price']}")
            
            # Mock du prix actuel stable (entre SL et TP)
            self.mock_executor.get_current_price = lambda: 43210.30
            print(f"üí∞ Prix actuel simul√©: 43210.30 (stable)")
            
            # Enregistrer le trade
            success = self.delayed_manager.register_trade_for_delayed_sltp(
                trade_result=trade_data,
                entry_candle_time=entry_time,
                original_sl_price=trade_data['sl_price'],
                original_tp_price=trade_data['tp_price']
            )
            
            print(f"‚úÖ Trade enregistr√©: {success}")
            
            if success:
                # Simuler l'attente (normalement fait par le thread de monitoring)
                print("‚è≥ Simulation attente...")
                time.sleep(1)
                
                # Forcer le traitement (simuler fin de bougie)
                print("üîÑ Traitement forc√©...")
                self.delayed_manager._process_delayed_trade(trade_id)
                
                result = "‚úÖ PASS - Pas d'offset appliqu√© (prix stable)"
            else:
                result = "‚ùå FAIL - √âchec enregistrement trade"
            
            self.test_results.append(("Sc√©nario 1 - Prix stable", result))
            print(f"\n{result}")
            
        except Exception as e:
            error_result = f"‚ùå FAIL - Erreur: {str(e)}"
            self.test_results.append(("Sc√©nario 1 - Prix stable", error_result))
            print(f"\n{error_result}")
            traceback.print_exc()
        
    def test_scenario_2_sl_depasse(self):
        """Test Sc√©nario 2: Prix d√©passe SL - Offset appliqu√©"""
        print("\n" + "="*60)
        print("üß™ TEST SC√âNARIO 2: SL d√©pass√© - Offset appliqu√©")
        print("="*60)
        
        try:
            # Configuration du test
            trade_id = "test_sl_breach_002"
            entry_time = datetime.now()
            
            # Trade LONG √† 43200, SL √† 43150, TP √† 43265
            trade_data = self.create_test_trade(
                trade_id=trade_id,
                side="LONG",
                entry_price=43202.50,
                quantity=0.023,
                sl_price=43150.00,
                tp_price=43265.00
            )
            
            print(f"üìä Trade test: {trade_data['side']} @ {trade_data['entry_price']}")
            print(f"   SL original: {trade_data['sl_price']}")
            print(f"   TP original: {trade_data['tp_price']}")
            
            # Mock du prix actuel SOUS le SL (SL d√©pass√©)
            current_price = 43140.20  # En dessous du SL de 43150
            self.mock_executor.get_current_price = lambda: current_price
            
            print(f"üí• Prix actuel simul√©: {current_price} (SL d√©pass√©!)")
            
            # Enregistrer le trade
            success = self.delayed_manager.register_trade_for_delayed_sltp(
                trade_result=trade_data,
                entry_candle_time=entry_time,
                original_sl_price=trade_data['sl_price'],
                original_tp_price=trade_data['tp_price']
            )
            
            print(f"‚úÖ Trade enregistr√©: {success}")
            
            if success:
                # Simuler l'attente
                print("‚è≥ Simulation attente...")
                time.sleep(1)
                
                # Forcer le traitement
                print("üîÑ Traitement forc√©...")
                self.delayed_manager._process_delayed_trade(trade_id)
                
                # V√©rifier r√©sultat attendu
                offset_percent = config.DELAYED_SLTP_CONFIG.get('PRICE_OFFSET_PERCENT', 0.01)
                expected_new_sl = current_price - (current_price * offset_percent / 100)
                
                result = f"‚úÖ PASS - SL ajust√© avec offset: {expected_new_sl:.2f} (√©tait {trade_data['sl_price']})"
            else:
                result = "‚ùå FAIL - √âchec enregistrement trade"
            
            self.test_results.append(("Sc√©nario 2 - SL d√©pass√©", result))
            print(f"\n{result}")
            
        except Exception as e:
            error_result = f"‚ùå FAIL - Erreur: {str(e)}"
            self.test_results.append(("Sc√©nario 2 - SL d√©pass√©", error_result))
            print(f"\n{error_result}")
            traceback.print_exc()
        
    def test_scenario_3_tp_depasse(self):
        """Test Sc√©nario 3: Prix d√©passe TP - Optimisation"""
        print("\n" + "="*60)
        print("üß™ TEST SC√âNARIO 3: TP d√©pass√© - Optimisation")
        print("="*60)
        
        try:
            # Configuration du test
            trade_id = "test_tp_breach_003"
            entry_time = datetime.now()
            
            # Trade LONG √† 43200, SL √† 43150, TP √† 43265
            trade_data = self.create_test_trade(
                trade_id=trade_id,
                side="LONG",
                entry_price=43202.50,
                quantity=0.023,
                sl_price=43150.00,
                tp_price=43265.00
            )
            
            print(f"üìä Trade test: {trade_data['side']} @ {trade_data['entry_price']}")
            print(f"   SL original: {trade_data['sl_price']}")
            print(f"   TP original: {trade_data['tp_price']}")
            
            # Mock du prix actuel AU-DESSUS du TP (TP d√©pass√©)
            current_price = 43280.50  # Au dessus du TP de 43265
            self.mock_executor.get_current_price = lambda: current_price
            
            print(f"üöÄ Prix actuel simul√©: {current_price} (TP d√©pass√©!)")
            
            # Enregistrer le trade
            success = self.delayed_manager.register_trade_for_delayed_sltp(
                trade_result=trade_data,
                entry_candle_time=entry_time,
                original_sl_price=trade_data['sl_price'],
                original_tp_price=trade_data['tp_price']
            )
            
            print(f"‚úÖ Trade enregistr√©: {success}")
            
            if success:
                # Simuler l'attente
                print("‚è≥ Simulation attente...")
                time.sleep(1)
                
                # Forcer le traitement
                print("üîÑ Traitement forc√©...")
                self.delayed_manager._process_delayed_trade(trade_id)
                
                # V√©rifier r√©sultat attendu
                offset_percent = config.DELAYED_SLTP_CONFIG.get('PRICE_OFFSET_PERCENT', 0.01)
                expected_new_tp = current_price + (current_price * offset_percent / 100)
                
                result = f"‚úÖ PASS - TP optimis√© avec offset: {expected_new_tp:.2f} (√©tait {trade_data['tp_price']})"
            else:
                result = "‚ùå FAIL - √âchec enregistrement trade"
            
            self.test_results.append(("Sc√©nario 3 - TP d√©pass√©", result))
            print(f"\n{result}")
            
        except Exception as e:
            error_result = f"‚ùå FAIL - Erreur: {str(e)}"
            self.test_results.append(("Sc√©nario 3 - TP d√©pass√©", error_result))
            print(f"\n{error_result}")
            traceback.print_exc()
        
    def test_scenario_4_statut_monitoring(self):
        """Test Sc√©nario 4: Statut et monitoring"""
        print("\n" + "="*60)
        print("üß™ TEST SC√âNARIO 4: Statut et monitoring")
        print("="*60)
        
        try:
            # Tester le statut avant ajout
            status_initial = self.delayed_manager.get_pending_trades_status()
            print(f"üìä Statut initial: {status_initial['total_pending']} trades")
            
            # Ajouter un trade de test
            trade_id = "test_monitoring_004"
            entry_time = datetime.now() - timedelta(minutes=1)  # Dans le pass√© = pr√™t
            
            trade_data = self.create_test_trade(
                trade_id=trade_id,
                side="LONG",
                entry_price=43200.00,
                quantity=0.02,
                sl_price=43150.00,
                tp_price=43265.00
            )
            
            success = self.delayed_manager.register_trade_for_delayed_sltp(
                trade_result=trade_data,
                entry_candle_time=entry_time,
                original_sl_price=trade_data['sl_price'],
                original_tp_price=trade_data['tp_price']
            )
            
            if success:
                # Tester le statut apr√®s ajout
                status = self.delayed_manager.get_pending_trades_status()
                
                print(f"üìä Statut des trades retard√©s:")
                print(f"   Total: {status['total_pending']}")
                print(f"   En attente: {status['waiting_for_candle_close']}")
                print(f"   Pr√™ts: {status['ready_for_processing']}")
                print(f"   Termin√©s: {status['completed']}")
                
                # Afficher d√©tails
                for trade_id_status, info in status['trades'].items():
                    print(f"   - {trade_id_status}: {info['side']} ({info['status']})")
                
                if status['total_pending'] > 0:
                    result = f"‚úÖ PASS - Monitoring fonctionne: {status['total_pending']} trades track√©s"
                else:
                    result = "‚ùå FAIL - Aucun trade track√©"
            else:
                result = "‚ùå FAIL - √âchec enregistrement trade"
            
            self.test_results.append(("Sc√©nario 4 - Monitoring", result))
            print(f"\n{result}")
            
        except Exception as e:
            error_result = f"‚ùå FAIL - Erreur: {str(e)}"
            self.test_results.append(("Sc√©nario 4 - Monitoring", error_result))
            print(f"\n{error_result}")
            traceback.print_exc()
        
    def run_all_tests(self):
        """Lance tous les tests"""
        print(f"\nüöÄ D√âBUT DES TESTS SL/TP RETARD√â")
        print(f"Configuration: {config.ASSET_CONFIG['SYMBOL']} - {config.ASSET_CONFIG['TIMEFRAME']}")
        print(f"Offset: {config.DELAYED_SLTP_CONFIG.get('PRICE_OFFSET_PERCENT', 0.01)}%")
        
        try:
            # Lancer tous les sc√©narios de test
            print("\nüéØ Lancement des tests...")
            self.test_scenario_1_prix_stable()
            self.test_scenario_2_sl_depasse()
            self.test_scenario_3_tp_depasse()
            self.test_scenario_4_statut_monitoring()
            
            # Afficher r√©sum√©
            self.display_test_summary()
            
        except Exception as e:
            print(f"‚ùå Erreur durant les tests: {e}")
            traceback.print_exc()
        finally:
            # Arr√™ter le monitoring si actif
            try:
                if hasattr(self.delayed_manager, 'monitoring_active') and self.delayed_manager.monitoring_active:
                    self.delayed_manager.stop_monitoring()
            except:
                pass
            
    def display_test_summary(self):
        """Affiche le r√©sum√© des tests"""
        print("\n" + "="*60)
        print("üìä R√âSUM√â DES TESTS")
        print("="*60)
        
        if not self.test_results:
            print("‚ö†Ô∏è Aucun test ex√©cut√©")
            return
        
        passed = 0
        failed = 0
        
        for test_name, result in self.test_results:
            status = "‚úÖ PASS" if "‚úÖ PASS" in result else "‚ùå FAIL"
            print(f"{status} - {test_name}")
            if "‚úÖ PASS" in result:
                passed += 1
            else:
                failed += 1
        
        print(f"\nüìà STATISTIQUES:")
        print(f"   Tests r√©ussis: {passed}")
        print(f"   Tests √©chou√©s: {failed}")
        print(f"   Total: {len(self.test_results)}")
        
        if failed == 0:
            print(f"\nüéâ TOUS LES TESTS R√âUSSIS!")
            print(f"Le syst√®me SL/TP retard√© fonctionne correctement.")
        else:
            print(f"\n‚ö†Ô∏è {failed} TESTS √âCHOU√âS")
            print(f"V√©rifiez la configuration et les logs.")

def run_interactive_test():
    """Mode test interactif"""
    print("üéÆ MODE TEST INTERACTIF")
    print("Commandes disponibles:")
    print("  1 - Test prix stable")
    print("  2 - Test SL d√©pass√©")
    print("  3 - Test TP d√©pass√©")
    print("  4 - Test monitoring")
    print("  all - Tous les tests")
    print("  quit - Quitter")
    
    try:
        tester = DelayedSLTPTester()
        
        while True:
            try:
                choice = input("\nChoisir un test: ").strip().lower()
                
                if choice == "quit":
                    break
                elif choice == "1":
                    tester.test_scenario_1_prix_stable()
                elif choice == "2":
                    tester.test_scenario_2_sl_depasse()
                elif choice == "3":
                    tester.test_scenario_3_tp_depasse()
                elif choice == "4":
                    tester.test_scenario_4_statut_monitoring()
                elif choice == "all":
                    tester.run_all_tests()
                    break
                else:
                    print("‚ùå Commande inconnue")
                    
            except KeyboardInterrupt:
                print("\nüëã Test interrompu")
                break
            except Exception as e:
                print(f"‚ùå Erreur: {e}")
                traceback.print_exc()
                
    except Exception as e:
        print(f"‚ùå Erreur initialisation testeur: {e}")
        traceback.print_exc()

if __name__ == "__main__":
    print("üß™ TESTEUR SYST√àME SL/TP RETARD√â")
    print("="*50)
    
    try:
        # Mode de lancement
        if len(sys.argv) > 1 and sys.argv[1] == "auto":
            # Mode automatique - tous les tests
            print("ü§ñ Mode automatique - Tous les tests")
            tester = DelayedSLTPTester()
            tester.run_all_tests()
        else:
            # Mode interactif
            print("üéÆ Mode interactif")
            run_interactive_test()
            
    except Exception as e:
        print(f"‚ùå Erreur principale: {e}")
        traceback.print_exc()
    
    print("\nüëã Test termin√©")